<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Nitty Gritties of Blockchain and Cryptocurrency Engineering</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="money/money.html"><strong aria-hidden="true">1.</strong> Money</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="money/payments.html"><strong aria-hidden="true">1.1.</strong> How payments work</a></li><li class="chapter-item expanded "><a href="money/ecash.html"><strong aria-hidden="true">1.2.</strong> Ecash</a></li></ol></li><li class="chapter-item expanded "><a href="signatures/signatures.html"><strong aria-hidden="true">2.</strong> Hash functions and signatures</a></li><li class="chapter-item expanded "><a href="consensus/consensus.html"><strong aria-hidden="true">3.</strong> Distributed consensus</a></li><li class="chapter-item expanded "><a href="signatures/signatures-indepth.html"><strong aria-hidden="true">4.</strong> Signatures indepth</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Nitty Gritties of Blockchain and Cryptocurrency Engineering</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>For many, cryptography can seem like an intimidating field. While online resources exist, they often lack a beginner-friendly approach. This lack of accessible information can be a barrier to understanding this crucial technology that underpins blockchain.</p>
<p>This book aims to bridge that gap. By focusing on fundamental concepts, it will provide a clear understanding of what cryptography is, how it works, and its role in securing blockchain technology. Blockchain itself is a revolutionary application of cryptography, and this book will delve into its inner workings, including digital signatures, consensus mechanisms, and tokenomics.</p>
<p>More than just understanding blockchain, this book will equip you with the knowledge to engineer your own cryptocurrency. It explores the essential tools and techniques used in cryptocurrency development, giving you a practical foundation to turn your ideas into reality.</p>
<p>We'll explore the revolutionary concept of a peer-to-peer (P2P) digital cash system, as first proposed by Satoshi Nakamoto in the Bitcoin whitepaper. You'll learn how cryptography, digital signatures, and consensus mechanisms work together to make this secure and transparent form of digital money possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="money"><a class="header" href="#money">Money</a></h1>
<blockquote>
<p>"The lack of money is the root of all evil."</p>
<p>~ Mark Twain, <em>The Prince and the Pauper</em></p>
</blockquote>
<p>There is something called the coincidence of ones. Suppose that I have a sheep and another person has wheat. I am hungry and I'd like to make bread and the other person would like to make a sweater. My sheep would be useful to the other person and the other person's wheat would be useful to me. We can barter.</p>
<p>What if the other person has vegetables and I don't want the vegetables but the other person still wants the wool from the sheep? How do we execute this trade? We don't have a coincidence of ones. Some theories suggest that money developed as a result of this problem.</p>
<p>The things that represented money had certain characteristics.</p>
<ol>
<li>
<p>They were rare</p>
</li>
<li>
<p>They were not easily reproducable</p>
</li>
</ol>
<p>Another theory about how many came about is the idea of receipts. I can store something of value somewhere in a depository and get a receipt which entitles me to the good being stored. The idea is money evolved out of trading this receipts. Whoever owns the receipt has access to the good stored in the depository.</p>
<h3 id="why-does-money-have-value"><a class="header" href="#why-does-money-have-value">Why does money have value?</a></h3>
<p>Money has value because we give it value. It's a collective story that we all tell. If you have a dollar bill and you want to buy something from someone, they are going to take it. And they know they can also make an exchange with it too.</p>
<p>Tokens are essentially digital representations of things that represent money. The reason that they have value is because we give them value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-payments-work"><a class="header" href="#how-payments-work">How Payments Work</a></h1>
<p>In traditional payments, banks keep records on a ledger of who owns what. Assume we have Alice and Bob, and Alice wants to pay Bob. Alice authenticates with a bank to prove she is Alice. The bank updates the ledger, debits the money from Alice's account, and credits Bob's account.</p>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<ul>
<li>Digital payments using banks ensure that the two parties don't have to be in the same location.</li>
</ul>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<ul>
<li>The bank must be online.</li>
<li>Privacy concerns.</li>
<li>The bank can censor transactions.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecash"><a class="header" href="#ecash">Ecash</a></h1>
<p>Designed to remove the double spending problem. In traditional Ecash, the bank creates a coin, i.e., a digital representation of a coin with a unique serial number on it. It then gives the coin with the serial number to Alice, and Alice can prove the bank produced the coin using something called digital signatures (we will explore them later). Alice gives the coin to Bob and gets the sandwich, and Bob goes back to the bank, and the bank confirms the serial number has not been spent. The problem with this is the bank has to be online.</p>
<h2 id="chaumian-ecash"><a class="header" href="#chaumian-ecash">Chaumian Ecash</a></h2>
<p>In chaumian Ecash, Alice generates the secret number
Alice then adds some randomness to the secret number so that the bank cannot see the secret number
The bank verifies on that blinded secret number and there is no way it knows that it came from Alice.</p>
<p>Alice requests for a coin b(SN) where b is the blinding factor.
The bank gives sig(b(SN)) where sig is the bank's signature.
Alice can remove the blinding factor and the coin is sig(SN), SN
Alice gives this to bob, Bob checks if this is a valid signature from the bank. The bank also records the secret number and it runs a list of secret numbers to make sure secret numbers aren't used more than once.</p>
<p>What if Alice gave the same to Charlie? This would be a double spend right? Well the way chaumian ecash works is that actually the bank stores more information and incase a double spend is detected, the bank will know that it was Alice who tried to double spend. Initially if no double spend, the bank wouldn't know but if double spend is detected, the bank will know it was alice and this is kind of a punishment and also a motivator for Alice not to do so.</p>
<p>This is a clever method and it has several pros:
1.Peer to peer 2. Offline double spend detection 3. Privacy</p>
<p>It still suffers from a big problem:</p>
<p>The bank can decide that they don't want to play this game with you.</p>
<p>The real question is how can we have a digital payment system that doesn't rely on a central party like a bank</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash-functions-and-signatures"><a class="header" href="#hash-functions-and-signatures">Hash functions and signatures</a></h1>
<p>The idea of a hash function is very simple but powerful.</p>
<p>hash(data)-&gt;output</p>
<p>A hash function takes in data of any size and produces an output of a fixed size.</p>
<p>The output of a hash function is ‘random looking’ but it is deterministic because if you provide the same input to the hash, you will get the same output.</p>
<p>Hash functions tend to exhibit particular traits, which you should consider if you are implementing your own hash functions from scratch (although it’s not recommended), one of which is called the “Avalanche effect.”</p>
<p>The Avalanche effect is the idea that changing 1 bit in the input of the hash function should change about half the output bits.</p>
<p>The second trait that a hash function should have is preimage resistance.</p>
<p>I’ll define preimage resistance as below:</p>
<p>Given y, you can’t find any x such that hash(x)==y.</p>
<p>You can find it eventually but that will take 2²⁵⁶ guesses which is not doable with current computers.</p>
<p>Hash functions should also have second preimage resistance. What this means is:</p>
<p>Given x and y such that hash(x)==y, you cannot find x¹ where x¹!=x and hash (x¹)==y.</p>
<p>A hash function should also be collision resistant. What this means is nobody can find any x, z such that x!=z and hash(x)==hash(z).</p>
<p>Again, you can find it theoretically after 2¹²⁸ guesses but practically this would take a huge amount of time with today’s hardware.</p>
<p>Practically speaking, collision resistance is harder to achieve. Some previous hash functions such as sha-1 and md5 have their collision resistance broken.</p>
<p>According to Wikipedia, “In early 2005, Vincent Rijmen and Elisabeth Oswald published an attack on a reduced version of SHA-1–53 out of 80 rounds — which finds collisions with a computational effort of fewer than 280 operations.[39]</p>
<p>In February 2005, an attack by Xiaoyun Wang, Yiqun Lisa Yin, and Hongbo Yu was announced.[5] The attacks can find collisions in the full version of SHA-1, requiring fewer than 269 operations. (A brute-force search would require 280 operations.)”</p>
<p>Hash functions are widely used to create digital signatures in blockchains like bitcoin.</p>
<h3 id="digital-signatures-and-lamports-signature-scheme"><a class="header" href="#digital-signatures-and-lamports-signature-scheme">Digital Signatures and Lamport’s signature scheme</a></h3>
<p>Simply put, digital signatures serve as proof that you’re the author of a message. Here’s how it works: You sign a message using a secret key. Then, you share the signature along with a public key. Anyone receiving this can verify that you indeed authored the message and possess the corresponding private key used for signing.</p>
<p>Here is how this is applied in Bitcoin. When you want to spend Bitcoin, you create a transaction. This transaction includes information about the sender, receiver, and the amount of Bitcoin being transferred. To authorize this transaction, you sign it with your private key.</p>
<p>Once you’ve signed the transaction, it’s broadcast to the Bitcoin network. Every node in the network verifies the transaction by checking the digital signature against the public key associated with the sending address. If the signature is valid, it confirms that the sender indeed owns the Bitcoin being spent and has the right to transfer it.</p>
<p>Lamport signatures are a type of cryptographic signature scheme based on a one-time secure hash function. They were proposed by Leslie Lamport in 1979.</p>
<p>Here is how it works:</p>
<ol>
<li>You have a function that generates a public key and a private key. The private key is generated from random characters, and the public key is the hash of the private key. Below is pseudocode to demonstrate this.</li>
</ol>
<pre><code>generate_keys():
 private_key = Array[2][n]
 for i from 0 to n-1:
 for j from 0 to n-1:
 private_key[i][j] = randomly_generate_bits()
 public_key = hash_each_element_of_private_key(private_key)
 return private_key, public_key

</code></pre>
<ol start="2">
<li>You then create a function called sign that takes in the message to sign and the private key. You hash the message and represent it in bits. Then you iterate through the message bits, and if the bit in the digest is 0, you select the corresponding bit from the first row of the private key and append it to an array called signature. Otherwise, you select the bit from the second row and append it to the signature array. At the end, you’ll have a signature made up of different parts of your private key.</li>
</ol>
<pre><code>sign(message, private_key):
 hashed_message = hash(message) // Hash the message
 signature = Array[n] // One-dimensional array to hold the signature
 for i from 0 to n-1:
 if hashed_message[i] == 0:
 signature[i] = private_key[0][i] // Use the first row of the private key if the corresponding bit in the hash is 0
 else:
 signature[i] = private_key[1][i] // Use the second row of the private key if the corresponding bit in the hash is 1
 return signature

</code></pre>
<ol start="3">
<li>Next, you implement a function called verify to check the validity of a signature. This function takes the original message, the signature, and the public key as inputs. Here's how it works:</li>
</ol>
<p>You first hash the original message using the same hash function used during signing, resulting in a digest.</p>
<p>Then, for each bit in the signature, you reconstruct the original digest by selecting the corresponding bit from the public key. If the bit in the signature is matched with the corresponding bit from the public key’s first row, it’s considered as a 0-bit; otherwise, it’s considered as a 1-bit.</p>
<p>After reconstructing the digest, you compare it with the hashed message. If they match, the signature is deemed valid; otherwise, it’s considered invalid.</p>
<pre><code>verify(message, signature, public_key):
    hashed_message = hash(message)
    reconstructed_hash = Array[n]  // One-dimensional array to hold the reconstructed hash
    for i from 0 to n-1:
        if signature[i] == public_key[0][i]:
            reconstructed_hash[i] = 0  // Reconstruct the hash using the first row of the public key if the signature matches
        else if signature[i] == public_key[1][i]:
            reconstructed_hash[i] = 1  // Reconstruct the hash using the second row of the public key if the signature matches
        else:
            return false  // If neither matches, the signature is invalid
    return reconstructed_hash == hashed_message  // Return true if the reconstructed hash matches the hashed message, false otherwise

</code></pre>
<p>I have written an implementation of this in Rust and you can check it out</p>
<p><a href="https://github.com/amschel99/lsig">https://github.com/amschel99/lsig</a></p>
<p>While the Lamport signature algorithm offers a basic method for generating and verifying digital signatures, its direct application to blockchain systems may be considered somewhat trivial or naive. This approach has some inherent limitations and challenges that need to be addressed for practical implementation in real-world blockchain applications. In a subsequent article, we will delve deeper into these limitations and explore more sophisticated methods for ensuring the security and efficiency of digital signatures on blockchains.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="distributed-consensus"><a class="header" href="#distributed-consensus">Distributed consensus</a></h1>
<p>We should begin with the Byzantine Generals Problem. It’s a game theory problem that describes the difficulty decentralized parties encounter in arriving at a consensus without relying on a central authority. A blockchain network should be permissionless, meaning anyone can join without needing to provide their identity. If we’re building a cryptocurrency, we need a globally ordered log, or you can think of it as a distributed database. You can compare this to a traditional bank database that records transaction information. However, this database should be replicated across all nodes in the network. This process is known as state machine replication. In such a network, multiple participants are involved, and they all need to agree on the system’s state. This issue is commonly referred to as distributed consensus.</p>
<p>In such a system, one critical thing needs to be addressed. What if some participants in the network decide to subvert the protocol? Since the system is permissionless, an attacker can decides to create multiple nodes, essentially for free and take over the network? This is what’s known as The Sybil Attack.</p>
<p>Proof of work is one of the most well-known solutions to the Sybil attack. In a nutshell, to create a new block on the blockchain requires a significant amount of computing resources such as electricity.</p>
<p>The difficulty of PoW ensures that adding new blocks to the blockchain requires substantial computational effort. This helps protect the network against Sybil attacks by making it difficult for attackers to overwhelm the network with a flood of fake transactions or blocks.</p>
<p>So how does this work technically?</p>
<p>Each block in the blockchain contains several pieces of information:</p>
<p>The hash of the previous block.
A set of transactions that represent changes to the Bitcoin ledger.
A nonce, which is a random number used to create a unique hash for the block.
The target, which is a specific value that the hash of the block must be below to be considered valid.
Miners compete to find a nonce that, when combined with the other block data, produces a hash that is below the target value. This process involves repeatedly hashing the block data with different nonce values until a suitable hash is found. Since the hash function used in Bitcoin (SHA-256) is deterministic and unpredictable, finding the correct nonce requires a significant amount of computational work.</p>
<p>The difficulty of finding the nonce is adjusted regularly to ensure that new blocks are added to the blockchain at a relatively constant rate, approximately every 10 minutes. The difficulty is determined by the target value, which is inversely proportional to the difficulty level. A lower target value means a higher difficulty, requiring more computational work to find a valid nonce.</p>
<p>Miners who successfully find a valid nonce and create a new block are rewarded with a predetermined number of bitcoins, along with any transaction fees included in the block. This incentive encourages miners to participate in the network and secure the blockchain.</p>
<p>Basically, miners use a ton of computer power to solve puzzles and create new blocks in the Bitcoin network. It’s like they’re competing to solve a really hard math problem, and whoever solves it first gets to add a block to the blockchain and earn some bitcoins.</p>
<p>The problem is, this process uses up a crazy amount of electricity and resources.</p>
<p>Ofcourse there are other consensus mechanisms such as Proof of stake used by etheureum but we will dive into thos later on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signatures-indepth"><a class="header" href="#signatures-indepth">Signatures indepth</a></h1>
<p>Apart from hash based Signatures(lamport signature scheme) there are other cool signatures. Hash based signatures are not used in bitcoin.</p>
<h4 id="disadvantages-of-lamport-signatures"><a class="header" href="#disadvantages-of-lamport-signatures">Disadvantages of lamport signatures</a></h4>
<ol>
<li>One time use</li>
<li>They are kind of huge (8kilobytes for a signature and keys are 16 kilobytes)</li>
</ol>
<h3 id="ellptic-curve-signatures"><a class="header" href="#ellptic-curve-signatures">Ellptic curve signatures</a></h3>
<p>Curves of the form y^2= x^3+ax+b
Bitcoin curve's is y^2= x^3+7</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
